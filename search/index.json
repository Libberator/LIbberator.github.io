[{"content":" Here as he walked by on the 16th of October 1843 Sir William Rowan Hamilton\nin a flash of genius discovered the fundamental formula for quaternion multiplication:\ni2 = j2 = k2 = ijk = -1\n—Plaque on Broom Bridge, Dublin # Intro So you want to learn about quaternions? Well, you\u0026rsquo;ve come to the right place. I\u0026rsquo;ll try my best to simplify it for you. This is written assuming that you know the following:\nVectors and/or Vector math fundamentals, the difference between \u0026ldquo;global\u0026rdquo; and \u0026ldquo;local\u0026rdquo;, or the term \u0026ldquo;relative to\u0026rdquo; I\u0026rsquo;ve split this article into four main parts:\nIntuition. How to think about them Properties of Quaternions Unity Methods and alternative rotational options Deeper dive into the Math behind them # Terminology You probably know already that a quaternion represents a \u0026ldquo;rotation\u0026rdquo;. Great! (Technically, they can be used for other things like scale, but not for our purposes. I digress\u0026hellip;) However, the term \u0026ldquo;rotation\u0026rdquo; is a bit overloaded, so to clarify the terminology I\u0026rsquo;ll be splitting it into two distinct terms (Note: these are not \u0026ldquo;official\u0026rdquo; or universally standardized terms):\nOrientation: the state or pose of an object. How the object is positioned/oriented in space. Rotation: the action or verb of rotating/turning/spinning an object. Specifically denotes the transformation or struct that will be applied to another rotation or orientation. Example Terminology Usage Consider an object initially facing East. \"Facing East\" represents an orientation. To make the object face South, we need to apply a rotation. If we say \"turn 90° about the Y axis\", this describes a rotation without explicitly mentioning the resulting orientation. It's like giving driving directions to a computer. When you see or hear \u0026ldquo;multiplying\u0026rdquo; (in the context of quaternions), it\u0026rsquo;s easier to instead think of \u0026ldquo;applying\u0026rdquo; - not in the sense of \u0026ldquo;setting\u0026rdquo; but rather \u0026ldquo;modifying by\u0026rdquo;. Multiplying a quaternion with a vector means you\u0026rsquo;re applying the rotation to the vector. If you\u0026rsquo;ve ever heard someone say \u0026ldquo;multiplying quaternions together is like adding them\u0026rdquo;, unlearn that. We don\u0026rsquo;t \u0026ldquo;add\u0026rdquo; quaternions in the traditional sense. Instead, one rotation gets applied to the other. It\u0026rsquo;s better in the long-run to think about them properly rather than lazily.\nAlso worth mentioning\u0026hellip;\nI will be using Unity\u0026rsquo;s coordinate system (X = right, Y = up, Z = forward), which is a Left-Handed coordinate system (i.e. satisfies Left-Hand Rule). If you don\u0026rsquo;t know what that means, look it up. In short: positive angles are CCW rotations when looking in the same direction of the axis you\u0026rsquo;re rotating about. # Intuition # Frame of Reference Are you looking to perform a relative rotation or a global one? Just like how a vector can represent either a global or local position, a quaternion struct can be global or local - it matters how you set them up and use them. Without any context, you can consider all quaternions to be global because you have nothing else to reference the rotation on. However, if you set up a quaternion using a relative value and apply it to the same object, that makes it a relative rotation. For instance, using transform.forward would make the rotation relative to the object\u0026rsquo;s Transform, while Vector3.forward represents a global rotation.\nIt\u0026rsquo;s generally not a good idea to try to share relative rotations with another object, especially if they started with a different orientation.\nDon\u0026rsquo;t confuse transform.rotation and transform.localRotation. Know the difference.\nAre you calculating a global orientation relative to the global XYZ coordinates (e.g. wanting to make your character face a target), then use the global-facing transform.rotation. If you only care about how it rotates with respect to its parent (e.g. Animations, door swinging on a hinge), then use transform.localRotation.\nBonus Tip: In Unity, toggle between \u0026ldquo;Local\u0026rdquo; and \u0026ldquo;Global\u0026rdquo; to see which axis is which on the Gizmo. Extra useful if you imported a model and the axes are set up differently.\n# Axis and Angles Look around yourself at all the things that do any kind of rotating. And I want you to think in terms of Axis and Angles. That\u0026rsquo;s a singular axis: a vector in *any* direction of your choice. This axis will be what gets rotated around by a certain amount of angular units. I\u0026rsquo;ll be using degrees, but radians are valid too.\nLeaning back in your chair? Nah. You\u0026rsquo;re rotating the chair negative degrees about its right axis (or positive degrees about the left axis).\nLooking down and to your left? Nah. Your neck is oriented some positive degrees around Vector(1, -1, 0), assuming Z is your forward. Might be tough to wrap your head around.\nGrab a pineapple. \u0026#x1f34d; Grab a pen. \u0026#x1f58a;\u0026#xfe0f; Make a Pineapple Pen. \u0026#x1f34d; \u0026#x1f58a;\u0026#xfe0f; That pen is the axis, at whatever arbitrary vector you stuck it in at. Spin it to see how it rotates.\nWhy think in terms of axis and angles? Because that\u0026rsquo;s more in line with how quaternions actually rotate. If you have a start and end orientation and want to interpolate between them, the shortest path is achieved with this kind of visualization. It\u0026rsquo;s like drawing two dots on a basketball and connecting it with the shortest line. Look at the path the dot needs to travel, and rotate it with an axis that\u0026rsquo;s perpendicular to that.\n# Why Euler Angles Suck Disclaimer: These reasons don\u0026rsquo;t really apply to standard 2D games, because you usually only rotate thing about a single Z axis. So it\u0026rsquo;s typically fine to use Euler Angles there.\nWhat are Euler Angles? It's a combination of 3 numbers representing the amount of angles rotated about each axes (X, Y, and Z), with a total range of 360° each. This is what you're used to using and seeing and what's displayed in Unity's Inspector for a Transform's \"Rotation\". #1. You can\u0026rsquo;t always trust the numbers you see in the Inspector\nThose numbers next to \u0026ldquo;Rotation\u0026rdquo; aren\u0026rsquo;t even its transform.rotation, but rather the Transform\u0026rsquo;s local orientation (i.e. relative to its parent). The Inspector lies to you, so don\u0026rsquo;t be fooled.\nDespite displaying as Euler angles, they\u0026rsquo;re actually a Quaternion behind the scenes. If you rotate around multiple axes, like for some 3D games, don\u0026rsquo;t use its Euler angles as a reference to base your logic off of. This is because the internal conversion that Unity does between Quaternions and Euler angles can have some of the angles \u0026ldquo;jumping around\u0026rdquo;, giving you unpredictable and unreliable behavior.\n#2. Euler Angles are subject to Gimbal Lock\n\u0026ldquo;What even is that?\u0026rdquo; you might be thinking. Let me Google that for you: \u0026ldquo;Gimbal Lock happens when two of the rotational axes align, causing a loss of one degree of freedom.\u0026rdquo; Okay, that wasn\u0026rsquo;t very helpful.\nBut it\u0026rsquo;s fairly easy to demonstrate with an actual example, so let\u0026rsquo;s do a \u0026ldquo;show, don\u0026rsquo;t tell\u0026rdquo; approach here. Put the following script on a GameObject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class GimbalLockExample : MonoBehaviour { [SerializeField] private float _speed = 50f; private float _pitch, _yaw, _roll; private void Update() { var pitchInput = Input.GetAxisRaw(\u0026#34;Vertical\u0026#34;); // W/S var yawInput = Input.GetAxisRaw(\u0026#34;Horizontal\u0026#34;); // A/D var rollInput = (Input.GetKey(KeyCode.Q) ? 1f : 0f) + (Input.GetKey(KeyCode.E) ? -1f : 0f); // Q/E _pitch += pitchInput * _speed * Time.deltaTime; _yaw += yawInput * _speed * Time.deltaTime; _roll += rollInput * _speed * Time.deltaTime; transform.rotation = Quaternion.Euler(_pitch, _yaw, _roll); } } Press \u0026lsquo;S\u0026rsquo; until you\u0026rsquo;ve pitched upwards 90° (\u0026ldquo;inverted controls\u0026rdquo; are just for this demo; I\u0026rsquo;m not a monster) so that the local forward vector aligns with the global Y-axis - this is when the red and blue rings align in the video below (at 0:10). Then you\u0026rsquo;ll see that any adjustment to Yaw (A/D) or Roll (Q/E) will be indistinguishable from one another; they both behave like Roll. That\u0026rsquo;s a loss of a degree of freedom (a.k.a. \u0026ldquo;gimbal lock\u0026rdquo;).\nYour browser doesn't support HTML5 video. Here is a link to the video instead. Play this Gimbal Lock demo for yourself! #3. Interpolation sucks\nAt the end of the Axis and Angles section, I pointed out that quaternions will interpolate along the shortest path. If you interpolate with Euler angles, well\u0026hellip; it\u0026rsquo;s not a straight path. It will be more like a soft \u0026ldquo;S\u0026rdquo;. Or it will just glitch out the rotation entirely, because Lerping one axis from 359° to 0° doesn\u0026rsquo;t move just 1° like you\u0026rsquo;d hope it would.*\n*This example assumes you\u0026rsquo;re manually handling the Lerping of Euler angles, and not using built-in Quaternion methods.\n#4. Dealing with the wrap-around point sucks\nHaving to add extra code to handle the transition between 0° and 360° (or -180° and 180°) to complete the circle is tedious. This is a situational game-dependent opinion, and sometimes unavoidable, but it\u0026rsquo;s still a pain. Clamping how far up and down you can look in an FPS is fine. But managing Eulers for handling Yaw in a Top-Down/3rd Person game feels wrong to me.\n# Properties of Quaternions # Unit Quaternions (Normalized) Unit quaternions have a ||magnitude|| of 1. This means if you square all four components and add them together, it should equal 1. Techincally should square-root it too, but $\\sqrt{1} = 1$, so I\u0026rsquo;m cutting corners. Within Unity, quaternions get normalized by default. There does exist a Normalize method in case you\u0026rsquo;re manually entering quaternion values and it, for some reason, doesn\u0026rsquo;t auto-normalize (it can happen). But usually you shouldn\u0026rsquo;t have to worry about that. Non-Unit Quaternions are more complicated things that I\u0026rsquo;m just not going to get into.\n# Identity (\u0026ldquo;1\u0026rdquo;) Identity just means \u0026ldquo;no change\u0026rdquo;. It\u0026rsquo;s like multiplying regular numbers by 1, or adding 0. When you set an object\u0026rsquo;s orientation to Quaternion.identity, it goes to the default orientation, which represents an absence of any rotations applied (i.e. 0° on all Euler Angles).\nQI = new Quaternion(0, 0, 0, 1);\n# Invertability (Ctrl + Z) The Inverse of a quaternion Q is denoted as Q-1. Any rotation that is applied can be undone. A quaternion will cancel out with its Inverse, resulting in the Identity quaternion. Thinking in terms of Axis and Angles, you can view it as negating the axis to point in the opposite direction, while keeping the same rotational angle. Another way to think about it is just negating the angle to rotate in the opposite direction. Mathematically speaking:\nQ-1 = new Quaternion(-Q.x, -Q.y, -Q.z, Q.w);\nQ * Q-1 = Q-1 * Q = QI (Identity)\nNote: There also exists a quaternion Conjugate, Q*, where the only difference is that Conjugate keeps the original magnitude and the Inverse is just the Conjugate divided by the square-magnitude. But since we\u0026rsquo;re working with Unit quaternions, the Inverse and Conjugate will be the same for our purposes, so I purposefully omitted any division operation for the Inverse.\n# Associativity (Parentheses order doesn\u0026rsquo;t matter) Given quaternions Q1, Q2, and Q3, associativity states that:\n(Q1 * Q2) * Q3 = Q1 * (Q2 * Q3)\nSame applies when multiplying with a vector V:\n(Q1 * Q2) * V = Q1 * (Q2 * V)\n# Non-Commutativity (Multiplcation order matters) Given quaternions Q1 and Q2, non-commutativity states that:\nQ1 * Q2 is not always the same as Q2 * Q1\nThere are some cases where they will just happen to be equal. Like if at least one of them is the Identity quaternion, if one is the Inverse of the other, or some other exceptions involving symmetry.\nWhen multiplying quaternions together, the best way to think about it is from right-to-left (I know, it seems backwards). Given Q1 * Q2 * V: start with the Vector direction, imagine rotating it first by Q2, then rotate that resulting vector by Q1. Order of operations is important to visualize the rotations. Alternatively, if you prefer left-to-right, you could try to visualize the result of Q1 * Q2 first, but I find that\u0026rsquo;s generally harder.\n# A \u0026ldquo;Complete\u0026rdquo; Rotation is 720°, Not Just 360° Your browser doesn't support HTML5 video. Here is a link to the video instead. By \u0026ldquo;complete\u0026rdquo;, I\u0026rsquo;m referring to an orientation returning to its starting state. If you track one face of the cube in the video (or gif at the top), you\u0026rsquo;ll see how this works where there are two different \u0026ldquo;states\u0026rdquo; even when the face of the cube is oriented the same way.\nThis is how it works in real life, too: Electrons and other matter particles in quantum mechanics have this property called \u0026ldquo;spin\u0026rdquo;. These two similar-but-different states are what physicists are referring to when they say \u0026ldquo;spin up\u0026rdquo; or \u0026ldquo;spin down\u0026rdquo;.\n# Unity Methods # Quaternion Creation Euler: Rotation that rotates z° around the z axis, x° around the x axis, and y° around the y axis. In that order Can access these values with transform.eulerAngles - not to be confused with transform.rotation If you\u0026rsquo;re typically setting two of the three values to 0°, you can accomplish the same thing with AngleAxis instead AngleAxis: Are you thinking in terms of axis and angles yet? You can create most of the same quaternions you\u0026rsquo;d probably make with Euler with this instead This method is FASTER, too! With a simple test of 100,000 calls every frame, AngleAxis outperformed Euler with 30-50% more FPS. Ditch using Euler; it\u0026rsquo;s a more expensive operation LookRotation: Get an orientation by providing a Vector3 forward and a Vector3 upwards. The upwards vector (default: Vector3.up) is used as a \u0026ldquo;hint\u0026rdquo; to determine how to orient the Roll Usually you\u0026rsquo;ll get a forward direction by doing target.position - transform.position Make sure your forward vector won\u0026rsquo;t directly align with the upward vector. Provide a new upward hint if that will be a problem Example AnalogyYou know how dogs do that cute little head-tilt when they're confused? Their eyes are still locked onto their target (you, probably after saying \"treat\" or \"walk\" to pique their interest) looking \"forward\". But their head's \"up\" reference is changing, no longer aligned with Vector3.up FromToRotation: This gets the difference in orientation between two direction vectors; the rotation that you would need to apply to fromDirection which will result in the toDirection. In other words, this solves for QFromTo in the equation QFromTo * VFrom = VTo This method was vital for my Roll-a-Tetrahedron solution Inverse: Gets the evil twin opposite rotation of a quaternion. Example: if you wanted to get QToFrom, you could call FromToRotation again swapping parameters or you could just do QToFrom = Quaternion.Inverse(QFromTo); The Quaternion Constructor: this takes in 4 floats x,y,z, and w. You usually won\u0026rsquo;t use this. If you are using this, it\u0026rsquo;s for one of the following reasons: deserialization optimizations (e.g. swizzling via extension methods) you understand quaternions better than most you copied code you found somewhere # Quaternion Interpolation When interpolating between a start and end orientation, Quaternions take the shortest path (this means that angles more than 180° apart aren\u0026rsquo;t a thing). Try to avoid having your start and end 180° apart (pointing in opposite directions), otherwise the path between them will not be well-defined.\n# Time- or Percent-Based Methods Lerp: Linear interpolation between [0-1] Slerp: Spherical interpolation between [0-1] LerpUnclamped \u0026amp; SlerpUnclamped: can also extrapolate beyond 0 and 1 What's the difference between Lerp and Slerp? Aren't they both spherical since it involves things that rotate? Yeah, not much difference tbh. Unlike the differences between Vector3's Lerp and Slerp, these all follow the same path but just have an ever-so-slightly different easing/timing along the path. The docs say that \"[Lerp] is faster than Slerp but looks worse if the rotations are far apart.\" But it's hard to see a difference Do LerpUnclamped and SlerpUnclamped behave the same? No. Because of how the math works with extrapolating and quaternions getting auto-normalized, LerpUnclamped \"fizzles out\" at certain values outside the 0-1 range, like diminishing returns. Unsatisfying.\nIn my tests, if the angle between the start and end orientations are less than ~36° apart, then SlerpUnclamped also behaves like LerpUnclamped. However, at larger starting angles, SlerpUnclamped shines and will properly extrapolate.\nFor example, if you wanted to extrapolate the Minute Hand on a Clock, your start and end orientations should be at least 6 minutes apart, but less than 30 minutes so that forward in time doesn't go the wrong way # Speed-Based Method RotateTowards: Get an orientation that is the from quaternion rotated by a float maxDegreesDelta angle towards the to quaternion without overshooting If you use a float rotationSpeed multiplied by Time.deltaTime, it will rotate at that rate in degrees per second, no matter the difference between from and to # Transform Options for Rotating Quaternions by theirself are just a math construct - they have no idea what a Transform is. With the Transform class, you have access to more contextual utility, like methods that know the difference between global and local.\nTransform.Rotate: This method has many overlaod options Primarily relies on Euler Angles or an Axis and Angle combo Can specify whether it\u0026rsquo;s a global (Space.World) or local (Space.Self) rotation (default) Transform.RotateAround: Like a satellite orbiting around a planet or like a hinge joint, this method also affects the position Uses an Axis and Angle and a world position Vector3 point as a pivot or anchor that the axis passes through Transform.LookAt: Immediately snap a transform\u0026rsquo;s forward to a Transform target or Vector3 worldPosition Similar to Quaternion.LookRotation, this also can take a Vector3 worldUp hint For 2D games, since this defaults to using the transform\u0026rsquo;s forward, you\u0026rsquo;ll either want to adjust the worldUp to have it orient towards a target (leaving the target vector directly forward of your character) OR change how your sprite is parented/oriented Applying a Vector3 direction directly to transform.forward/up/right This approach doesn\u0026rsquo;t give control over where the other axes choose to align, so use cautiously or only in very simple cases Applying a Quaternion rotation directly to transform.rotation or transform.localRotation Tip: If you have someRotation you want to apply to your transform\u0026rsquo;s orientation, don\u0026rsquo;t do transform.rotation *= someRotation;! Instead, do transform.rotation = someRotation * transform.rotation;. Order matters # Quaternion Methods You\u0026rsquo;ll Never or Rarely Use Normalize: Set the magnitude of a quaternion to 1, keeping its orientation. Unity does this by default in most cases Dot: Returns the Dot Product between two quaternions, a value between -1 and +1 as a measure of \u0026ldquo;alignment\u0026rdquo;. Easier to use Vectors Angle: Returns the angle in degrees between two quaternions. Easier to use Vectors ToAngleAxis: Gets an Angle and Axis from a quaternion. Usually you\u0026rsquo;re using that kind of info to create quaternions, not the other way around Fun fact: the axis that gets returned from Quaternion.identity is Vector3.right, or (1, 0, 0) # Math Quaternions consist of four numbers: x, y, z, and w*, which are all values between -1 and +1. But that still leaves us with questions:\nShould we try to visualize it geometrically? What do those numbers mean? How does multiplying with them work? *Note: I\u0026rsquo;ll be placing w at the end to match with Unity; other sources may put the w at the beginning.\n# Geometric Interpretation It can be hard for people to visualize a 4-dimensional struct. Imagine a coordinate system that consists of 4 axes. By definition, all four axes are perpendicular to each other. Oh, and three of the four axes are imaginary.\nThat\u0026rsquo;s not very helpful or intuitive.\nInstead, it\u0026rsquo;s easier to imagine a quaternion in two parts: a Vector3 (using x, y, and z) with a certain amount of spin or twist about itself (the w component). This goes back to thinking in terms of Axis and Angle. The trickier part comes when trying to interpret how the w value relates to an actual angular value.\n# Imaginary Numbers The magical rotational properties stem from the usage of imaginary numbers: $i = \\sqrt{-1}$\nBrief refresher on the Complex Plane, $\\mathbb{C}$: it\u0026rsquo;s a 2D grid, where the horizontal axis consists of real numbers, $\\mathbb{R}$, and the vertical axis consists of imaginary numbers, $\\mathbb{I}$. A point in the grid is called a complex number, written as a + bi. Any time you multiply a complex number by i, it\u0026rsquo;s like rotating that point 90° counter-clockwise about the origin. If you do that 4 times, you\u0026rsquo;re back to where you started: 1 → i → -1 → -i → 1\nLet\u0026rsquo;s extend the Complex Plane by adding two more imaginary dimensions: j and k. Both j and k also have the rotational superpowers that come from $\\sqrt{-1}$. All four axes (1, i, j, and k) are orthogonal to one another, forming a \u0026ldquo;basis\u0026rdquo; in our 4D space. We can represent a quaternion in the form:\n$$ x\\mathbb{i} + y\\mathbb{j} + z\\mathbb{k} + w $$\nIt\u0026rsquo;s worth pointing out that the real axis where w occupies has a unit value of 1. It\u0026rsquo;s just omitted in the formula for convenience: $\u0026hellip; + w*1$. This will be useful info later when we\u0026rsquo;re multiplying quaternions.\nTo make sense of how multiplication with these new axes works, we need to add a few special rules. And remember: the order of multiplication matters. The value on the left is being applied to the one on the right:\ni * j = k, j * i = -k j * k = i, k * j = -i k * i = j, i * k = -j\nClick here for an interactive visualization of these rules Now we can make sense of what Sir Hamilton etched into stone (see quote at top of this article):\ni2 = j2 = k2 = ijk = -1 For that ijk part, whether you do the multiplication like (i * j) * k or i * (j * k), you can use the rules to replace what\u0026rsquo;s in the parentheses and you\u0026rsquo;ll get (k) * k = -1 or i * (i) = -1, respectively. Yay associativity!\n# The Real Part: w Since w is a value between -1 and +1, how can we map that from/to an angle of rotation?\nAnswer: $ w = \\cos{(\\theta / 2)} $, and $ \\theta = 2 * \\arccos{w} $\nWhen w is 1, x, y, and z will be 0 due to normalization constraints. This is the same as Quaternion.identity, where the angle of rotation is 0°.\nAlthough a w value of 0 may seem insignificant, it actually represents the most extreme rotation: 180°.\nWhat about when w is -1? The other values will be forced to be 0 just as before because normalization, but the angle is actually 360°.\nIs this last case the same as Quaternion.identity? No. When applied to a 3D model, it will look the exact same, the Angle difference between this and Identity will be 0°, but an equality check will return false. Remember: A \"Complete\" Rotation is 720°, Not Just 360°. If you applied this twice, then it will be equal to the Identity. In a way, you could consider this to be the 2nd root of the Identity. # From Axis \u0026amp; Angle to Quaternion This is to demonstrate how to do var q = Quaternion.AngleAxis(angle, axis); if you didn\u0026rsquo;t have access to that Unity method\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1. First define your axis and your angle var axis = new Vector3(4f, 20f, 69f); var angle = 100f; // 2. Get the w from the angle. Remember to convert to radians var w = Mathf.Cos(angle * Mathf.Deg2Rad / 2f); // 3. Get the downscaling factor that we\u0026#39;ll apply to the vector var downscale = Mathf.Sin(angle * Mathf.Deg2Rad / 2f); // 4. Downscaling the vector ensures all 4 values combined will be normalized var xyz = axis.normalized * downscale; // 5. Make your Quaternion var q = new Quaternion(xyz.x, xyz.y, xyz.z, w); # From Quaternion to Axis \u0026amp; Angle This is to demonstrate how to do q.ToAngleAxis(out var angle, out var axis); if you didn\u0026rsquo;t have access to that Unity method\n1 2 3 4 5 6 7 // 1. Assuming we already have a quaternion \u0026#39;q\u0026#39; defined, get the angle in degrees var angle = 2f * Mathf.Rad2Deg * Mathf.Acos(q.w); // 2. Extract the vector portion. Normalize it just because var axis = new Vector3(q.x, q.y, q.z).normalized; // That\u0026#39;s it. Return those or assign to out parameter # Q*Q Multiplication If you know the basics of multiplication, addition, and subtraction, you can perform quaternion multiplication!\nSince we know the form of a quaternion, and we\u0026rsquo;re only plugging in the values for x, y, z, and w, we can set up a multiplication table for the axes and use the special rules from earlier to simplify the math:\ni j k 1 i -1 k -j i j -k -1 i j k j -i -1 k 1 i j k 1 For QA * QB, QA would be along the left column, and QB would be along the top row. If you swap them, you\u0026rsquo;ll just have some minus signs in the wrong spots.\nStep-by-Step Example\nIn this example, imagine we\u0026rsquo;re looking at a computer monitor slightly to our right at 30° and want to turn our neck left by 120°.\nQA = 0i - 0.866j + 0k + 0.5 ← rotation same as Quaternion.AngleAxis(-120f, Vector3.up)\nQB = 0i + 0.2588j + 0k + 0.9659 ← orientation same as Quaternion.AngleAxis(30, Vector3.up)\nUse a matrix table to perform QA * QB\n0 i 0.2588 j 0 k 0.9659 0 i 0 0 0 0 -0.866 j 0 0.22414 0 -0.8365 j 0 k 0 0 0 0 0.5 0 0.1294 j 0 0.48296 Combinining like terms gives us: QB\u0026rsquo; = 0i - 0.7071j + 0k + 0.7071\nConverting that quaternion to an Angle and Axis tells us it\u0026rsquo;s a 90° rotation about the negative Y-axis. Using the left-hand-rule, this orientation represents looking directly left. We did it! That wasn\u0026rsquo;t too bad.\n# Q*V Multiplication I know I wrote Q * V, but actually we have to do Q * V * Q-1, sandwiching the vector between the quaterion and its inverse*. Yummy. This is to ensure the w value gets properly canceled out so that we\u0026rsquo;re left with a Vector in the end and not actually a quaternion.\n*Note: In Unity, you can\u0026rsquo;t perform V * Q in that order. This math section is how to solve it on paper, and it\u0026rsquo;s more-or-less what happens behind the scenes when you do a Q * V operation in Unity.\nNot the best analogy, but here\u0026rsquo;s one way to think about it the sandwiching: Imagine wringing out a wet towel. Both hands start facing the same direction as each other, palms down gripping the towel. One hand twists the towel in one direction 180° (Q). The other hand twists it 180° in the opposite direction (Q-1). Both hands end up still facing the same way as each other, but the towel (V) ends up twisted (rotated) and slightly less soaked.\nSo how do we multiply something that lives in 3D space by something that\u0026rsquo;s 4D? They live in very different spaces - real world vs complex imaginary land. Here\u0026rsquo;s the trick:\nWe pretend our vector is actually 4D like a quaternion, setting the w value to 0. We don\u0026rsquo;t do any normalzing to it. We\u0026rsquo;ll call it V4D We do the same quaternion multiplication as before but just twice. It doesn\u0026rsquo;t matter which pair you multiply first: (Q * V4D) * Q-1 = Q * (V4D * Q-1) After all the multiplication math dust settles, if we did it right, its w will end up as 0 and so we drop that real axis. We also drop the imaginary labels i, j, and k from it to convert it back to a regular Vector, now rotated Longer Step-by-Step Example\nIn this example, let\u0026rsquo;s start with a (7, 7, 0) vector and try to rotate that counter-clockwise by 45°. Relatively simple 2D example that you could solve using the Rotation Matrix, but let\u0026rsquo;s demonstrate what it looks like with quaternions\nV = 7x + 7y + 0z\nQ = 0i + 0j + 0.38268k + 0.92388 ← rotation same as Quaternion.AngleAxis(45f, Vector3.forward)\nQ-1 = 0i + 0j - 0.38268k + 0.92388 ← Inverse to sandwich with\nLet\u0026rsquo;s pretend that V is a quaternion. I\u0026rsquo;m choosing to perform V4D * Q-1 first\n0 i 0 j -0.38268 k 0.92388 7 i 0 0 2.67876 j 6.46716 i 7 j 0 0 -2.67876 i 6.46716 j 0 k 0 0 0 0 0 0 0 0 0 Combinining like terms gives us V4D\u0026rsquo; = 3.7884i + 9.14592j + 0k + 0\nHalf-way there. Now we multiply Q * V4D\u0026rsquo;\n3.7884 i 9.14592 j 0 k 0 0 i 0 0 0 0 0 j 0 0 0 0 0.38268 k 1.45 j -3.5 i 0 0 0.92388 3.5 i 8.45 j 0 0 Simplifying one last time gives us V4D\u0026rsquo; = 0i + 9.9j + 0k + 0\nConverting the final result back into 3D world space gives us a vector of (0, 9.9, 0). Awesome!\n# Conclusion Visualizing the rotations and getting a solid point of reference (local, global, relative to something else?) can be daunting. But now you know the essentials and to think about them in terms of and axis and an angle, so go out there and practice with them! Think about what sort of scenarios would be suitable for different methods. Don\u0026rsquo;t multiply them in the wrong order. Level up beyond the pedestrian Euler angles. Being able to use Quaternions is an invaluable tool to have as a gamedev. And they\u0026rsquo;re pretty nifty too \u0026#x1f44d;\n# Bonus Material and Resources # FAQ I want to interpolate between a start and end orientation, but with the long/outer path. How can I achieve this? As with anything program-related, there are lots of potential solutions. Here is one approach using SlerpUnclamped: public Quaternion SlerpLongPath(Quaternion from, Quaternion to, float t) { var angle = Quaternion.Angle(from, to); // angle along short path if (angle == 0) return from; // avoid divide-by-zero float adjustedT = t * (angle - 360f) / angle; // remaps t from [0,1] to [0,-N] return Quaternion.SlerpUnclamped(from, to, adjustedT); } Pop Quiz: In what situation will the above code not give desired results? Answer: When the Angle between from and to is less than ~36°. See Quaternion Interpolation for details If that's going to be a problem, here is a different approach that uses a mid-point that we flip around: public Quaternion SlerpLongPath(Quaternion from, Quaternion to, float t) { var midRot = Quaternion.Slerp(from, to, 0.5f); // orientation along short path midRot.ToAngleAxis(out var midAngle, out var midAxis); // niche use for this method var midRotLong = Quaternion.AngleAxis(midAngle + 180f, midAxis); // opposite dir of short path if (t \u003c 0.5f) return Quaternion.Slerp(from, midRotLong, 2 * t); return Quaternion.Slerp(midRotLong, to, 2 * t - 1); } With this approach, if from and to are identical or exactly 180° apart, the long path is not strongly defined so results may vary # Videos Visualizing quaternions (31:50) - 3Blue1Brown, part 1 Quaternions and 3d rotation (5:58) - 3Blue1Brown, part 2 How quaternions produce 3D rotation (11:34) - PenguinMaths # Reading How Quaternions Produce 3D Rotations - PenguinMaths Rotation and orientation in Unity - Unity Docs. Short \u0026rsquo;n sweet Quaternion - Wikipedia # Further Reading Let\u0026rsquo;s remove Quaternions from every 3D Engine - Marc ten Bosch. Interesting read. Suggests Rotors Conversion between quaternions and Euler angles - Wikipedia. Did not cover this. Heavy math ","date":"2023-07-04T12:00:00-07:00","image":"https://hugelolcdn.com/hugewoah.com/i/7950.gif","permalink":"https://libberator.github.io/p/quaternions/","title":"Your Guide to Quaternions"},{"content":"A member of a Discord server I moderate was curious about how to roll a tetrahedron. And that intrigued me. It\u0026rsquo;s such a unique problem. They wanted something similar to Tarodev\u0026rsquo;s \u0026ldquo;Roll-A-Cube\u0026rdquo; video.\nSearching for a pre-existing solution to see if this had been done before turned up nothing. So I got to work. Engineering a solution to a unique problem involves trial and error, and I\u0026rsquo;ve purposefully included any non-working attempts so that you can follow along with the process.\nFor my initial approach, I\u0026rsquo;ll try modifying the Roll-A-Cube code, which uses the RotateAround method. But before we get to that, we\u0026rsquo;ll need a 3D model to work with.\n# 3D Tetrahedron Model The requirements I set for myself were the following:\nEdge length of 1 unit (a.k.a. \u0026ldquo;unit tetrahedron\u0026rdquo;). Bottom face is level with the XZ-plane (y = 0).* Top vertex is centered directly above the origin. Pointy end forward (though this can easily also point right, not a hard-set constraint). Precision is important so I can\u0026rsquo;t rely on downloading someone else\u0026rsquo;s model. *Note: This was just for easier math; we will offset it later so the center is at the origin.\nWith this setup, I did the math (I will leave the fun of trigonometric computations to the reader) and came out with the following 4 vertices:\n1 2 3 4 Back-left: (-0.5, 0, -0.288675) // z = -sqrt(3)/6 Back-right: (0.5, 0, -0.288675) Forward: (0, 0, 0.577350) // z = 1/sqrt(3) Top: (0, 0.816497, 0) // y = sqrt(2/3) All 4 vertices are 1 unit away from each other and sqrt(3/8) units away from the center:\n1 Center is at: (0, 0.2041241, 0) // y = sqrt(6)/12 If you want to try deriving it for yourself, I also recommend a linear algebra approach by setting up a few system of equations to solve for the unknowns. Alternatively, you can check out the Tetrahedron Wikipedia page for examples, and apply your desired scaling and offset.\nWith these 4 vertices, we can now create our mesh. How you choose to do this is up to you:\n3D Modeling Software (i.e. Blender) - Benefits are: easier customizations like smoothing edges, UV/Texture maps, etc. ProBuilder in Unity - New Shape \u0026gt; Cone \u0026gt; Radius = 0.5773503, Height = 0.8164966, Sides = 3. Note: This didn\u0026rsquo;t feel as accurate and will require modified code to work with later because it’s not a regular Mesh but a ProBuilderMesh. Generate Mesh via code - I\u0026rsquo;ve created a script to generate it for you in one click. I purposefully offset the mesh vertices down so that the center is at the origin. This makes it easier for rotating. Once you have the mesh generated, it\u0026rsquo;s time to set up the GameObject structure. It\u0026rsquo;s generally a good practice to keep the visuals separate from the logic. We\u0026rsquo;ll classify the rotation as part of the visuals, but the movement still needs to be applied to the root object. Set it up with the mesh as a child object, then gave the child\u0026rsquo;s local position the appropriate y-offset.\n# RotateAround Approach Transform.RotateAround requires 3 pieces of information:\nA Vector3 axis to rotate around A Vector3 point, a world-space anchor, for which the axis passes through A float angle of rotation in degrees We need to access the world positions of the vertices to get the axis and point to rotate around. If you were to access the vertex info from the MeshRenderer\u0026rsquo;s Mesh data, they would be returned as local offsets. They can be converted to world coordinates with transform.TransformPoint(vertexOffset). Alternatively, we can add 4 Transforms as children, use vertex-snapping (by holding v) to position them, and add them to a List\u0026lt;Transform\u0026gt; _vertices, which is what I\u0026rsquo;ll use for this example.\nSince we\u0026rsquo;re just prototyping for a proof-of-concept at this stage, quick iteration is more important than performance, so we can do a quick-and-dirty Linq statement:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // in case input isn\u0026#39;t already swizzled for 3D var dir = new Vector3(horizontalInput, 0f, verticalInput); // acts as our \u0026#34;carrot on a stick\u0026#34;, used for a distance check var target = transform.position + dir; // given world position vertices, ignore top-most vertex and take the closest two var closestVertices = _vertices.Where(v =\u0026gt; v.position.y \u0026lt; 0.5f) .OrderBy(v =\u0026gt; Vector3.Distance(v.position, target)) .Take(2).ToArray(); // the direction of the axis vector is important for how RotateAround works var axis = closestVertices[1].position - closestVertices[0].position; // we can use the Cross Product to know if this will rotate correctly if (Vector3.Cross(dir, axis).y \u0026lt; 0f) // the resulting vector should point upwards axis = -axis; // either vertex (index 0 or 1) will work for the anchor point var anchor = closestVertices[0].position; Finally, we\u0026rsquo;ll need the angle of rotation. For a cube, it\u0026rsquo;s an easy 90°. But for a tetrahedron, it\u0026rsquo;s a bit harder to calculate. Spoiler alert: it\u0026rsquo;s 109.4712206..°, or acos(-1/3). According to the wiki page, this is the same as the \u0026ldquo;Vertex-Center-Vertex\u0026rdquo; angle. However, I initially solved it for the angle between two faces, also known as the \u0026ldquo;dihedral angle\u0026rdquo;, then subtracted that from 180°.\n# RotateAround Results Your browser doesn't support HTML5 video. Here is a link to the video instead. So this will work. If performance is a concern, replace Linq with something that doesn\u0026rsquo;t generate garbage. If you\u0026rsquo;re happy with those results, you can stop reading here, grab the complete script, and enjoy the rest of your day. \u0026#x1f38a;\nBut it does have some limitations to be aware of:\nOver a long distance, after many rolls, some error will accumulate and the orientation won\u0026rsquo;t be perfectly flush. This is because the angle of rotation is an irrational number, and there will be floating point errors. It\u0026rsquo;s not very easy to apply an easing function to alter the feel of the roll with RotateAround. With those limitations in mind, what are some other potential ways to rotate a tetrahedron?\nRigidbody \u0026amp; AddTorque - physics isn\u0026rsquo;t always reliable; we want more control over how it moves. \u0026#x274c; Hard-code all 6 possible orientations and their transitions - too inflexible, feels hacky, lots of work. \u0026#x274c; Get target rotations procedurally with raycasts and use quaternions - seems promising, let\u0026rsquo;s try it! \u0026#x2714;\u0026#xfe0f; # Procedural Approach The main issue we want to avoid from before is compounding errors. Every rotation should be independent and absolute. Meaning: if one rotation under- or over-shoots, the next should have a definitive target so that errors don\u0026rsquo;t add up. Previously, RotateAround handled both rotation and movement, so we\u0026rsquo;ll need to handle the movement part separately.\nHere’s the plan:\nThe input direction will be used for a raycast to hit 1 of the faces. We\u0026rsquo;ll use the normal of the triangle to loosely represent an orientation (no need to keep track of vertices anymore). That face should end up on the bottom, where its normal will point down, so we calculate the required rotation to make that happen. And then we\u0026rsquo;ll figure out movement later. # Determining the Rotation If we want to hit the correct face from the outside with a raycast, we\u0026rsquo;ll want to use a LayerMask to avoid other objects potentially intercepting that ray. Or\u0026hellip; now hear me out\u0026hellip; we start our raycast from the inside. By default, raycasts won\u0026rsquo;t hit the back-side of triangle faces. We can solve that in one of two ways: recreate the mesh so that the fronts of the triangles are visible from the inside (i.e. make it double-sided), or simply enable it with:\n1 Physics.queriesHitBackfaces = true; // also found in Project Settings \u0026gt; Physics I\u0026rsquo;m choosing this simpler option.\nSide note: if you ever want to add a Rigidbody, Unity complains that the mesh isn\u0026rsquo;t \u0026ldquo;convex\u0026rdquo;. And if you tick the Convex checkbox on the Mesh Collider, the raycasts won\u0026rsquo;t detect the back faces for some reason.\nPop Quiz When you get a RaycastHit result from inside of a tetrahedron (i.e. hitting the backface) and read the hit.normal, which direction does the normal vector point: inward or outward? Answer: It’s outward still. The normal for the face hasn't changed. If you\u0026rsquo;re unfamiliar with Quaternions, check out my other post explaining them! For now just know they represent rotations and/or orientations. They can interpolate more accurately than using Euler angles, always taking the shortest path, and aren\u0026rsquo;t subject to gimbal lock.\nWith the goal to rotate so that the hit face ends up on the bottom, we can get the target orientation with the following code:\n1 2 3 4 // required rotation that gets us from A to B var deltaRot = Quaternion.FromToRotation(hit.normal, Vector3.down); // we know A already, this gives us B so that we can interpolate between the two var targetRot = deltaRot * _center.rotation; // where _center is the child Transform Note: The order of multiplying quaternions together matters. The left-hand-side will be applied to the right-hand-side.\n# Determining the Movement To figure out how far we need to move, that\u0026rsquo;s just twice the distance from the center of an equilateral triangle to the middle of an edge. The total distance is 1/sqrt(3), so we can make that a variable:\n1 private const float ONE_OVER_ROOT_THREE = 0.5773503f; To get the direction, we can use the normal again and just zero-out the y-component and normalize it:\n1 var moveDir = new Vector3(hit.normal.x, 0f, hit.normal.z).normalized; The end position after a full rotation will be:\n1 var targetPos = transform.position + ONE_OVER_ROOT_THREE * moveDir; It\u0026rsquo;s worth mentioning that there is still a chance for some positional error accumulation. If you have a very large map where the position needs to be accurate to a grid, you\u0026rsquo;ll want to grab the coordinates from the grid cell instead. You can set up your own coordinate system or just raycast the ground triangle and cleverly use hit.barycentricCoordinate. But this will work for our purposes without over-engineering.\n# Interpolating/Tweening Now that we have figured out our targets for rotation and movement, we need to interpolate. There are many options to achieve this:\nYour choice of tweening library if they support quaternion rotations Create a coroutine utilizing any of the following Lerp Slerp RotateTowards / MoveTowards Since we\u0026rsquo;re still prototyping, I will start out with DOTween. It\u0026rsquo;s basically a coroutine without having to write all of the boilerplate, and it\u0026rsquo;s free from the asset store.\n# DOTween Rotating is as simple as calling this one line:\n1 2 // _timeToMove is a shared float for moving and rotating. 0.5f seconds worked fine transform.DORotateQuaternion(targetRot, _timeToMove); // bonus: add .SetEase(Ease.OutSine) Note: DOTween suggests to use DORotate, but don\u0026rsquo;t; that method uses euler angles and we know how that turns out.\nWe also need to move our object up then down smoothly as it moves. Fortunately, DOTween has our back with:\n1 transform.DOJump(targetPos, _jumpPower, 1, _timeToMove); After tweaking the _jumpPower to stay in contact with the ground, a value of ⅙ was good enough: 0.166f\nIt looks promising! However\u0026hellip; there\u0026rsquo;s one small detail that I don\u0026rsquo;t like\u0026hellip;\nIt doesn\u0026rsquo;t stay anchored.\nWhy doesn't it stay anchored? We need the path of the jump to be circular, since it just goes along a 109.47..° arc of a circle. And the shape of the path for DOJump is likely to be parabolic (or something that isn't circular). We don't have control over the underlying code behind DOJump to adjust its path, and it cannot be fixed by just using a different Ease either.\nSo we can't use DOJump. What's my proposed solution? We could use some combination of DOMove, DOLocalMoveY, or some other DOTween method to create the right path, but I have a better idea in mind. Looking at our options for interpolating, one of them stands out in particular to work with circular (spherical) rotations: Slerp.\nTime to write our own coroutine. # Coroutine with Slerp The rotation in the coroutine also requires that we first cache the start so that we can properly Slerp between the start and target.\n1 2 3 4 5 6 7 /* Coroutine setup */ var deltaRot = Quaternion.FromToRotation(hit.normal, Vector3.down); var startRot = _center.rotation; var targetRot = deltaRot * startRot; /* Applied every frame in the coroutine */ _center.rotation = Quaternion.Slerp(startRot, targetRot, t); If you\u0026rsquo;ve never used Vector3.Slerp before, think of it like a windshield wiper. A vector gets rotated from pointing in one direction to pointing in another. With that in mind, we need to mainly work with offsets, which we then add onto a world position reference point - an anchor.\nIn this diagram, the Slerp operation would move a vector along a circular path, depicted by the gray arrow. To achieve moving the parent (transform.position) along the yellow curved path, this is the relevant parts of the movement code:\n1 2 3 4 5 6 7 8 9 10 11 12 /* Declared at the top */ private const float ROOT_THREE_OVER_SIX = 0.288675135f; // half the previously-declared const /* Coroutine setup */ var moveDir = new Vector3(hit.normal.x, 0f, hit.normal.z).normalized; var halfStep = ROOT_THREE_OVER_SIX * moveDir; var startOffset = _center.localPosition - halfStep; // notice localPosition usage for offset var targetOffset = _center.localPosition + halfStep; var anchor = transform.position - startOffset; /* Applied every frame in the coroutine */ transform.position = anchor + Vector3.Slerp(startOffset, targetOffset, t); And that\u0026rsquo;s it! With this approach, it\u0026rsquo;s very easy to add an AnimationCurve for a custom easing function and it doesn\u0026rsquo;t rely on a third-party asset.\nYour browser doesn't support HTML5 video. Here is a link to the video instead. You can grab the complete script here.\nHappy rolling!\n","date":"2023-02-01T12:00:00-07:00","permalink":"https://libberator.github.io/p/roll-a-tetrahedron/","title":"Roll-A-Tetrahedron"},{"content":" \"Any fool can write code that a computer can understand.\nGood programmers write code that humans can understand.\"\n— Martin Fowler # Listen Up We need to talk.\nNo, I don\u0026rsquo;t mean that in the \u0026ldquo;you\u0026rsquo;re in trouble\u0026rdquo; sense, but more literally: we need to be able to communicate more clearly. When something is written in text, it can be hard to determine the *intent* behind the words or where they\u0026rsquo;re coming from. Words and phrases can have many different meanings to different people, often requiring surrounding context to decipher. But what if you aren\u0026rsquo;t given enough context or can\u0026rsquo;t infer intent? (see: Key \u0026amp; Peele - \u0026ldquo;When a Text Conversation Goes Very Wrong\u0026rdquo;)\nThat\u0026rsquo;s where coding/naming conventions come in. \u0026#x1f60d; They\u0026rsquo;re like the emojis of modern communication, able to pack a lot of info in such a small space. \u0026#x1f4af;\nIn the dev community, this can be a very sensitive topic - people have strong opinions about this. But that\u0026rsquo;s what this is: an opinion. A personal preference. The most important thing is: whatever you choose, be consistent within your code base.\nNote: This article will mainly focus on the formatting or syntax aspect of C# programming, not so much on the \u0026ldquo;how to pick a name for a variable\u0026rdquo; part.\n# Why Should You Care? Avoid conflicts. Did you forgot to specify this.foo and accidentally used foo, a different variable? With good naming conventions, you won\u0026rsquo;t ever run into this mistake. You also won\u0026rsquo;t ever need to type this, except for extension methods or passing an object as an argument.\nSpeed up development. If you\u0026rsquo;re reading code, it will let you immediately know the scope or source of a variable. If you\u0026rsquo;re writing code and are blanking on what you called a certain private field, you can just type _ and your IDE will list them all for you. Reduces times spent scrolling.\nWorking with others (including future self). It\u0026rsquo;s easier to parse a co-worker\u0026rsquo;s code, and vice-versa.\nSome ways of writing are just easier to read than oThErwaYSOFwRiTiNG. The reader\u0026rsquo;s focus should be on the code content rather than any distracting inconsistent formatting.\n# Basic Naming Conventions At a minimum, you should have 3 distinct ways to immediately identify whether a variable is:\npublic private local (method parameter or created inside a method) Microsoft has a detailed article covering this topic:\nhttps://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions\nI follow the majority of them, with some differences. Here is a non-exhaustive summary of my preferred coding conventions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace Libberator.Conventions; // \u0026#34;File-Scoped Namespaces\u0026#34; is a C# 10 feature // Classes - always PascalCase public class ClassName : ISomeInterface // interfaces start with an \u0026#34;I\u0026#34; { // Fields private int _privateField; // private fields camelCase with leading underscore protected bool _protectedField; // protected fields camelCase with leading underscore public string PublicField; // public is PascalCase. Prefer properties over public fields public const float PI = 3.14159f; // const is always SCREAMING_CAPS private const string MY_GREETING = \u0026#34;Hello\u0026#34;; // use $\u0026#34;{string} {interpolation}\u0026#34; when possible // Properties - always PascalCase public int RegularProperty { get =\u0026gt; _privateField; protected set =\u0026gt; _privateField = value; } public string AutoProperty { get; set; } // automatically creates its own backing field public bool GetOnlyProperty =\u0026gt; _protectedField; // expression bodies to reduce number of lines // Methods - always PascalCase. Prefer being explicit with access modifiers like \u0026#34;private\u0026#34; private void PrivateMethod(int someParameter) // parameters always camelCase, no underscore { if (someParameter \u0026lt; _privateField) return; // use guard clauses to reduce indentations var someLocalVariable = 100; // local variables always camelCase, no underscore } } # Why I Format protected More Like private Than public Microsoft\u0026rsquo;s article states [emphasis mine]:\nIn the following examples, any of the guidance pertaining to elements marked public is also applicable when working with protected and protected internal elements, all of which are intended to be visible to external callers.\nThe protected access modifier is intended to be used for inheritance. If you never inherit from the class that has protected stuff inside, they\u0026rsquo;re essentially the same as just being private. Other non-inherited classes don\u0026rsquo;t have access to protected things. If it were public-facing, I\u0026rsquo;d give it PascalCase. They wrote \u0026ldquo;\u0026hellip;visible to external callers\u0026rdquo;, but a class inheriting from another is not an \u0026ldquo;external caller\u0026rdquo; in my opinion. Just like real-world inheritance, the genes get passed down - they become a part of you.\nWorking with protected variables inside a class is very similar to working with private variables so that\u0026rsquo;s why I make them camelCase with a leading underscore. Is it important to know whether the variable originated in your class or in one of its parents? Not particularly. It\u0026rsquo;s more important for me to know if any external class has the ability to access it directly.\n# To var Or Not To var I use var all the time. As much as possible. Most of the time, its type can be easily inferred by what\u0026rsquo;s on the right-hand-side of the assignment operator. If there\u0026rsquo;s any chance of confusion for what type something is, the variable name should be descriptive enough to clear it up. To be clear, this does not mean to ever use Hungarian Notation.\nSimilar to how I\u0026rsquo;m explicit with private, I also prefer to be explicit with how I write numbers. While float num = 42; is the same as float num = 42f; due to implicit conversion, var num = 42; is not the same as var num = 42f; — one is an int, the other is a float. Therefore, it\u0026rsquo;s a good habit to always write the f after your number when you\u0026rsquo;re working with floats. The main mistake I see new programmers make is when they use UnityEngine\u0026rsquo;s Random.Range(lowerBound, upperBound);. The int version of that method has the upper bound as exclusive, whereas the float version\u0026rsquo;s upper bound is inclusive. Not knowing what \u0026ldquo;exclusive\u0026rdquo; means is a common source of off-by-1 errors.\nProgramming becomes simpler when you can just focus on the logic implementation and not be distracted by the types making it slower to write and harder to read. Now don\u0026rsquo;t get me wrong, I love statically-typed languages; knowing what type a variable is is important. But writing your code in a way that reads closer to plain English or pseudocode is much easier to follow along. I don\u0026rsquo;t think there\u0026rsquo;s much to gain by purposefully avoiding var. It\u0026rsquo;s a feature of the language for a reason.\n# Bracket Indentation There are two leading styles when it comes to where the brackets get placed.\nAllman:\n1 2 3 4 5 6 7 public void BracketOnNewLine() { while (true) { // code } } K\u0026amp;R:\n1 2 3 4 5 public void BracketOnSameLine() { while (true) { // code } } This shouldn\u0026rsquo;t be much of a surprise if you looked at the previous block of code, but I prefer Allman style. I like seeing where the scope of one section of code begins and ends. Arguments against would say, \u0026ldquo;But that\u0026rsquo;s so much vertical space!\u0026rdquo; and that\u0026rsquo;s valid; I, too, enjoy reading succint code and not having to scroll as much.\nThat being said, most methods shouldn\u0026rsquo;t be so large to begin with that it would require scrolling. Take advantage of ternary operators. If that\u0026rsquo;s not easy to parse, extract it as an expression-bodied property with a human-readable name. If there\u0026rsquo;s only a single thing inside the brackets, omit the brackets entirely. Whether the follow-up logic is on the same line as the condition or the next depends on the length or complexity of the line (see previous guard clause).\n# General Philosophy \u0026amp; Tips Your code should read like prose; it should flow as easily as reading any sentence. Some might say \u0026ldquo;like poetry\u0026rdquo; because there is an art to it, but I\u0026rsquo;ve seen some cryptic and fragmented poetry in my day.\nLinq is great for readability and making your code succinct, but it has some performance considerations. Try to avoid it for things in the hot path.\nLet your IDE help you.\nRefactoring names. Attention to detail is important. Tpyo\u0026rsquo;s happpen. Alot. Know your IDE\u0026rsquo;s shortcut for renaming. If you\u0026rsquo;re not sure if you\u0026rsquo;ve spelled something correctly, look it up. Method Extraction (for self-documenting code). Reduce comment usage. If you have a comment explaining what something is doing (e.g. // this gets all the active Players), you can instead extract that portion of code into its own clearly-named method or property (e.g. GetActivePlayers() or ActivePlayers). This helps break down larger code sections into more digestible chunks. It will read more like pseudocode which in turn makes it easier to reason about the logic or for fixing bugs. Linter. This is a tool that identifies and, if configured, automatically formats your code to adhere to coding standards and stylistic conventions. Bonus (this one might just be a pet peeve): Wherever you share your code seeking feedback (StackOverflow, Reddit, Discord, etc.), use code block Markdown. Add syntax highlighting if it\u0026rsquo;s available and remove any unnecessary indentation. You\u0026rsquo;re much more likely to get others to read your code if it\u0026rsquo;s legible.\n# Final Remarks Every choice of character should be purposeful, reducing or entirely removing ambiguity. It should serve as a way to densely pack and relay information. As succinct as an emoji. \u0026#x1f609; (Disclaimer: please don\u0026rsquo;t code with emojis)\nI\u0026rsquo;ve discussed some of the basics on how to format or style your code for consistency and legibility. I hope you are using a coding convention and are consistent with it. And I hope your chosen convention at least differentiates between public, private, and local. You\u0026rsquo;ll thank your past self and others will appreciate you for using a coding convention.\n\"There are only three hard things when it comes to programming: naming things and off-by-1 errors.\" There is so much more on the topic of how to choose a name for a variable or method it deserves an entire post of its own.\nThanks for listening.\n","date":"2023-01-06T12:00:00-07:00","image":"https://libberator.github.io/p/naming-conventions/code_quality_hue10b4217b2057d588cfa8463f7032127_80020_120x120_fill_box_smart1_3.png","permalink":"https://libberator.github.io/p/naming-conventions/","title":"Naming Conventions"}]